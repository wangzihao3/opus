# 优化 silk_noise_shape_quantizer_del_dec_neon 函数性能

## 概述

优化 SILK 噪声形状量化器延迟决策 ARM NEON 内联函数的性能，目标是提升 ARM 平台上 Opus 编码器的实时性能。

## Why

优化 SILK 噪声形状量化器延迟决策 ARM NEON 函数，提升 ARM 平台上 Opus 编码器的实时性能。当前实现存在多个性能瓶颈，包括内存访问模式、分支预测、循环展开等方面都有优化空间。

## What Changes

- 优化 `silk_noise_shape_quantizer_del_dec_neon` 函数（位于 `silk/arm/NSQ_del_dec_neon_intr.c`）
- 实现 5 个关键优化点：
  1. AR_shp_Q28 内存访问向量化（目标 5-8% 性能提升）
  2. LTP 预测计算向量化（目标 3-5% 性能提升）
  3. 噪声反馈环路展开（目标 8-12% 性能提升）
  4. Lambda_Q10 分支优化（目标 2-4% 性能提升）
  5. 状态更新批量化（目标 3-5% 性能提升）
- **编译配置**：必须使用 `--enable-fixed-point` 选项编译
- **测试要求**：每个优化点都需要独立的性能测试数据支持
- 保持与 C 版本的位级一致性和音频质量（PESQ 偏差 < 0.05）

## Impact

- **受影响的代码**: `silk/arm/NSQ_del_dec_neon_intr.c`（特别是行 544-923 的 `silk_noise_shape_quantizer_del_dec_neon` 函数）
- **受影响的平台**: ARM NEON 平台（aarch64）
- **受影响的规格**: `performance-testing`（新增性能测试要求）
- **编译依赖**: 必须使用 `--enable-fixed-point` 选项
- **测试影响**: 需要新增性能基准测试和验证流程
- **向后兼容性**: 完全兼容，不影响 API 和输出格式

## 当前状态
- `silk_noise_shape_quantizer_del_dec_neon` 函数位于 `silk/arm/NSQ_del_dec_neon_intr.c:544`
- 该函数是 SILK 编码器的关键路径，对编码性能有显著影响
- 当前实现使用 NEON intrinsics 进行 SIMD 优化，但仍有改进空间

### 性能影响分析
通过代码审查，识别出以下性能瓶颈：

1. **内存访问模式**（行 598-606, 652-653）
   - `AR_shp_Q28` 数组初始化使用了标量循环处理剩余元素
   - `sLPC_Q14` 状态数组的访问模式可能存在缓存未命中

2. **LTP 预测计算**（行 620-633）
   - 仅对 `TYPE_VOICED` 信号类型进行展开循环优化
   - `b_Q14` 系数访问可以预取优化

3. **噪声反馈环路**（行 666-678）
   - `shapingLPCOrder` 循环内部多次内存加载/存储
   - `AR_shp_Q28` 系数加载每次迭代都进行

4. **量化候选计算**（行 704-769）
   - RDO（率失真优化）分支可能造成流水线停顿
   - Lambda_Q10 条件判断导致分支预测失败

5. **状态更新循环**（行 875-889）
   - 多个嵌套循环更新延迟决策状态
   - 内存拷贝操作可以批量优化

### 需求约束

#### 必须满足
1. 编译时使用 `--enable-fixed-point` 选项（定义 `FIXED_POINT` 宏）
2. 每个优化点都需要性能测试数据支持
3. 保持与 C 版本 `silk_noise_shape_quantizer_del_dec` 的位级一致性
4. 不得影响音频质量（PESQ、POLQA 等指标）

#### 期望满足
1. 支持 ARM NEON 平台（aarch64）
2. 保持代码可维护性
3. 避免增加代码体积超过 20%

## 目标

### 主要目标
1. 在 `--enable-fixed-point` 配置下，函数执行时间减少 **15-30%**
2. 使用标准性能测试工具测量优化效果（如 `perf`, Google Benchmark）

### 次要目标
1. 减少缓存未命中率
2. 优化内存访问模式
3. 提升指令级并行性

## 技术方案

### 优化策略

#### 1. 内存访问优化
- **目标区域**: 行 598-606（AR_shp_Q28 初始化）
- **优化方法**:
  - 完全使用 NEON 向量加载处理所有元素（避免标量回退）
  - 使用 `vld1q_s16_x4` 进行四路交错加载
- **预期收益**: 5-8% 性能提升

#### 2. LTP 预测向量化
- **目标区域**: 行 620-633（LTP_pred_Q14 计算）
- **优化方法**:
  - 将 `b_Q14` 系数和 `pred_lag_ptr` 加载向量化
  - 使用多项式展开减少乘法指令
- **预期收益**: 3-5% 性能提升（仅限 VOICED 信号）

#### 3. 噪声反馈环路展开
- **目标区域**: 行 666-678（shapingLPCOrder 循环）
- **优化方法**:
  - 4x 循环展开减少迭代次数
  - 预加载 `AR_shp_Q28` 系数到寄存器
  - 使用结构化加载/存储减少内存事务
- **预期收益**: 8-12% 性能提升

#### 4. 分支优化
- **目标区域**: 行 712-725（Lambda_Q10 条件）
- **优化方法**:
  - 使用无分支选择指令（`vbslq_s32`）替代条件分支
  - 利用 NEON 的比较和掩码操作
- **预期收益**: 2-4% 性能提升

#### 5. 状态更新批量化
- **目标区域**: 行 875-889（sLPC_Q14 更新）
- **优化方法**:
  - 使用 `memcpy` 或 NEON 批量拷贝
  - 减少循环迭代次数
- **预期收益**: 3-5% 性能提升

### 测试验证策略

#### 性能测试要求
1. **基准测试工具**:
   - 使用 Google Benchmark 框架或自定义 `clock_gettime()` 测量
   - 至少 100,000 次迭代取平均值
   - 测试 Warm-up 和 Cold-start 两种场景

2. **测试数据集**:
   - 多种音频类型（语音、音乐、混合）
   - 不同采样率（8kHz, 16kHz, 48kHz）
   - 不同比特率（6kb/s, 24kb/s, 64kb/s）

3. **性能指标**:
   - 单次调用耗时（纳秒）
   - 每秒处理帧数（FPS）
   - CPU 周期数（使用 `perf stat`）
   - 缓存命中率（L1d, L1i, LLC）

4. **正确性验证**:
   - 与 C 版本对比输出比特流完全一致
   - PESQ 分数偏差 < 0.05
   - 编码器输出文件大小一致

5. **平台覆盖**:
   - ARM Cortex-A53（典型移动设备）
   - ARM Cortex-A72/A76（高性能服务器）
   - Apple M1/M2（如果可用）

## 风险与缓解

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 优化导致数值误差 | 中 | 高 | 严格的单元测试和比特流对比 |
| 性能提升不达标 | 低 | 中 | 分阶段验证，每个优化点独立测试 |
| 特定平台性能退化 | 中 | 中 | 多平台测试，保留回退路径 |
| 代码可维护性下降 | 低 | 低 | 详细注释，性能测试文档化 |
| 编译器行为差异 | 中 | 中 | 使用 GCC 和 Clang 双重验证 |

## 实施计划

详细的任务分解参见 `tasks.md`。

## 依赖关系

- 需要 ARM NEON 硬件支持或 QEMU 模拟器
- 需要性能分析工具（`perf`, `valgrind/cachegrind`）
- 需要音频测试数据集

## 成功标准

1. 所有性能测试数据达到预期目标
2. 通过现有所有单元测试
3. 音频质量指标无明显下降
4. Code Review 通过
5. 文档完整（性能测试报告、优化说明）

## 参考资料

- ARM NEON Intrinsics Reference: https://developer.arm.com/architectures/instruction-sets/intrinsics/
- Opus 编解码器规范: RFC 6716
- 当前实现: `silk/arm/NSQ_del_dec_neon_intr.c:544`
- C 参考实现: `silk/NSQ_del_dec.c:84`
